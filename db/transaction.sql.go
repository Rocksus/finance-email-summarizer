// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: transaction.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getUserAccount = `-- name: GetUserAccount :one
SELECT
    ua.account_id,
    ua.user_id,
    ua.account_name,
    ua.magnified_balance_summary + COALESCE(
        (
            SELECT
                SUM(
                    CASE
                        WHEN at.transaction_type = 0 THEN at.magnified_transaction_amount
                        WHEN at.transaction_type = 1 THEN - at.magnified_transaction_amount
                    END
                )
            FROM
                account_transaction at
            WHERE
                at.account_id = ua.account_id
                AND at.created_at > ua.rollup_at
        ),
        0
    ) AS magnified_balance_summary,
    ua.created_at,
    ua.updated_at,
    ua.rollup_at,
    ua.currency
FROM
    user_account ua
WHERE
    ua.account_id = $1
`

type GetUserAccountRow struct {
	AccountID               int64
	UserID                  int64
	AccountName             string
	MagnifiedBalanceSummary int32
	CreatedAt               pgtype.Timestamptz
	UpdatedAt               pgtype.Timestamptz
	RollupAt                pgtype.Timestamptz
	Currency                string
}

func (q *Queries) GetUserAccount(ctx context.Context, accountID int64) (GetUserAccountRow, error) {
	row := q.db.QueryRow(ctx, getUserAccount, accountID)
	var i GetUserAccountRow
	err := row.Scan(
		&i.AccountID,
		&i.UserID,
		&i.AccountName,
		&i.MagnifiedBalanceSummary,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RollupAt,
		&i.Currency,
	)
	return i, err
}

const insertAccountTransaction = `-- name: InsertAccountTransaction :one
INSERT INTO
    account_transaction (
        transaction_id,
        account_id,
        user_id,
        transaction_name,
        magnified_transaction_amount,
        transaction_type,
        category_id,
        created_at,
        updated_at,
        notes,
        created_by
    ) VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11
    ) RETURNING transaction_id, account_id, user_id, transaction_name, magnified_transaction_amount, transaction_type, category_id, created_at, updated_at, notes, created_by
`

type InsertAccountTransactionParams struct {
	TransactionID              pgtype.UUID
	AccountID                  int64
	UserID                     int64
	TransactionName            string
	MagnifiedTransactionAmount int64
	TransactionType            int32
	CategoryID                 int64
	CreatedAt                  pgtype.Timestamptz
	UpdatedAt                  pgtype.Timestamptz
	Notes                      string
	CreatedBy                  string
}

func (q *Queries) InsertAccountTransaction(ctx context.Context, arg InsertAccountTransactionParams) (AccountTransaction, error) {
	row := q.db.QueryRow(ctx, insertAccountTransaction,
		arg.TransactionID,
		arg.AccountID,
		arg.UserID,
		arg.TransactionName,
		arg.MagnifiedTransactionAmount,
		arg.TransactionType,
		arg.CategoryID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Notes,
		arg.CreatedBy,
	)
	var i AccountTransaction
	err := row.Scan(
		&i.TransactionID,
		&i.AccountID,
		&i.UserID,
		&i.TransactionName,
		&i.MagnifiedTransactionAmount,
		&i.TransactionType,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Notes,
		&i.CreatedBy,
	)
	return i, err
}

const insertUserAccount = `-- name: InsertUserAccount :one
INSERT INTO
    user_account (
        user_id,
        account_name,
        currency,
        magnified_balance_summary
    )
VALUES
    ($1, $2, $3, $4) RETURNING account_id, user_id, account_name, magnified_balance_summary, created_at, updated_at, rollup_at, currency
`

type InsertUserAccountParams struct {
	UserID                  int64
	AccountName             string
	Currency                string
	MagnifiedBalanceSummary int64
}

func (q *Queries) InsertUserAccount(ctx context.Context, arg InsertUserAccountParams) (UserAccount, error) {
	row := q.db.QueryRow(ctx, insertUserAccount,
		arg.UserID,
		arg.AccountName,
		arg.Currency,
		arg.MagnifiedBalanceSummary,
	)
	var i UserAccount
	err := row.Scan(
		&i.AccountID,
		&i.UserID,
		&i.AccountName,
		&i.MagnifiedBalanceSummary,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RollupAt,
		&i.Currency,
	)
	return i, err
}

const listTransactionByAccountID = `-- name: ListTransactionByAccountID :many
SELECT
    transaction_id,
    account_id,
    user_id,
    transaction_name,
    magnified_transaction_amount,
    transaction_type,
    category_id,
    created_at,
    updated_at,
    notes,
    created_by
FROM
    account_transaction
WHERE
    account_id = $1
LIMIT
    $2 OFFSET $3
`

type ListTransactionByAccountIDParams struct {
	AccountID int64
	Limit     int32
	Offset    int32
}

func (q *Queries) ListTransactionByAccountID(ctx context.Context, arg ListTransactionByAccountIDParams) ([]AccountTransaction, error) {
	rows, err := q.db.Query(ctx, listTransactionByAccountID, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountTransaction
	for rows.Next() {
		var i AccountTransaction
		if err := rows.Scan(
			&i.TransactionID,
			&i.AccountID,
			&i.UserID,
			&i.TransactionName,
			&i.MagnifiedTransactionAmount,
			&i.TransactionType,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Notes,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rollupUserAccountBalance = `-- name: RollupUserAccountBalance :exec
UPDATE
    user_account ua
SET
    magnified_balance_summary = magnified_balance_summary + COALESCE(
        (
            SELECT
                SUM(
                    CASE
                        WHEN at.transaction_type = 0 THEN at.magnified_transaction_amount
                        WHEN at.transaction_type = 1 THEN - at.magnified_transaction_amount
                    END
                )
            FROM
                account_transaction at
            WHERE
                at.account_id = user_account.account_id
                AND at.created_at > user_account.rollup_at
                AND at.created_at <= $1
        ),
        0
    ),
    rollup_at = $1
WHERE
    ua.account_id = $2
`

type RollupUserAccountBalanceParams struct {
	RollupAt  pgtype.Timestamptz
	AccountID int64
}

func (q *Queries) RollupUserAccountBalance(ctx context.Context, arg RollupUserAccountBalanceParams) error {
	_, err := q.db.Exec(ctx, rollupUserAccountBalance, arg.RollupAt, arg.AccountID)
	return err
}
